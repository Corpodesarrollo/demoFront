//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class TS_DirectorioGeneral {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/DirectorioGeneral/API";

    }

    /**
     * @return Success
     */
    estado(nomTREF: string, cancelToken?: CancelToken | undefined): Promise<ResumenTablaReferencia> {
        let url_ = this.baseUrl + "/estado/{nomTREF}";
        if (nomTREF === undefined || nomTREF === null)
            throw new Error("The parameter 'nomTREF' must be defined.");
        url_ = url_.replace("{nomTREF}", encodeURIComponent("" + nomTREF));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEstado(_response);
        });
    }

    protected processEstado(response: AxiosResponse): Promise<ResumenTablaReferencia> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResumenTablaReferencia.fromJS(resultData200);
            return Promise.resolve<ResumenTablaReferencia>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResumenTablaReferencia>(null as any);
    }

    /**
     * @return Success
     */
    indexGet2(nomTREF: string, cancelToken?: CancelToken | undefined): Promise<TablaReferencia> {
        let url_ = this.baseUrl + "/{nomTREF}";
        if (nomTREF === undefined || nomTREF === null)
            throw new Error("The parameter 'nomTREF' must be defined.");
        url_ = url_.replace("{nomTREF}", encodeURIComponent("" + nomTREF));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIndexGet(_response);
        });
    }

    protected processIndexGet2(response: AxiosResponse): Promise<TablaReferencia> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TablaReferencia.fromJS(resultData200);
            return Promise.resolve<TablaReferencia>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TablaReferencia>(null as any);
    }

    /**
     * @return Success
     */
    indexGet(nomTREF: string, codigo: string, cancelToken?: CancelToken | undefined): Promise<TablaReferencia> {
        let url_ = this.baseUrl + "/{nomTREF}/{codigo}";
        if (nomTREF === undefined || nomTREF === null)
            throw new Error("The parameter 'nomTREF' must be defined.");
        url_ = url_.replace("{nomTREF}", encodeURIComponent("" + nomTREF));
        if (codigo === undefined || codigo === null)
            throw new Error("The parameter 'codigo' must be defined.");
        url_ = url_.replace("{codigo}", encodeURIComponent("" + codigo));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIndexGet(_response);
        });
    }

    protected processIndexGet(response: AxiosResponse): Promise<TablaReferencia> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TablaReferencia.fromJS(resultData200);
            return Promise.resolve<TablaReferencia>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TablaReferencia>(null as any);
    }

    /**
     * @return Success
     */
    fechaHora( cancelToken?: CancelToken | undefined): Promise<Date> {
        let url_ = this.baseUrl + "/fechaHora";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFechaHora(_response);
        });
    }

    protected processFechaHora(response: AxiosResponse): Promise<Date> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
    
            return Promise.resolve<Date>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Date>(null as any);
    }

    /**
     * @return Success
     */
    machineName( cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/machineName";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMachineName(_response);
        });
    }

    protected processMachineName(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class Item implements IItem {
    codigo?: string | undefined;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    habilitado?: boolean | undefined;
    extra_I?: string | undefined;
    extra_II?: string | undefined;
    extra_III?: string | undefined;
    extra_IV?: string | undefined;
    extra_V?: string | undefined;
    extra_VI?: string | undefined;
    extra_VII?: string | undefined;
    extra_VIII?: string | undefined;
    extra_IX?: string | undefined;
    extra_X?: string | undefined;
    valor?: string | undefined;
    creation?: Date;
    lastUpdate?: Date;

    constructor(data?: IItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.codigo = _data["codigo"];
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            this.habilitado = _data["habilitado"];
            this.extra_I = _data["extra_I"];
            this.extra_II = _data["extra_II"];
            this.extra_III = _data["extra_III"];
            this.extra_IV = _data["extra_IV"];
            this.extra_V = _data["extra_V"];
            this.extra_VI = _data["extra_VI"];
            this.extra_VII = _data["extra_VII"];
            this.extra_VIII = _data["extra_VIII"];
            this.extra_IX = _data["extra_IX"];
            this.extra_X = _data["extra_X"];
            this.valor = _data["valor"];
            this.creation = _data["creation"] ? new Date(_data["creation"].toString()) : <any>undefined;
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Item {
        data = typeof data === 'object' ? data : {};
        let result = new Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["codigo"] = this.codigo;
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        data["habilitado"] = this.habilitado;
        data["extra_I"] = this.extra_I;
        data["extra_II"] = this.extra_II;
        data["extra_III"] = this.extra_III;
        data["extra_IV"] = this.extra_IV;
        data["extra_V"] = this.extra_V;
        data["extra_VI"] = this.extra_VI;
        data["extra_VII"] = this.extra_VII;
        data["extra_VIII"] = this.extra_VIII;
        data["extra_IX"] = this.extra_IX;
        data["extra_X"] = this.extra_X;
        data["valor"] = this.valor;
        data["creation"] = this.creation ? this.creation.toISOString() : <any>undefined;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IItem {
    codigo?: string | undefined;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    habilitado?: boolean | undefined;
    extra_I?: string | undefined;
    extra_II?: string | undefined;
    extra_III?: string | undefined;
    extra_IV?: string | undefined;
    extra_V?: string | undefined;
    extra_VI?: string | undefined;
    extra_VII?: string | undefined;
    extra_VIII?: string | undefined;
    extra_IX?: string | undefined;
    extra_X?: string | undefined;
    valor?: string | undefined;
    creation?: Date;
    lastUpdate?: Date;
}

export class ResumenTablaReferencia implements IResumenTablaReferencia {
    tref?: string | undefined;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    habilitado?: boolean;
    lastUpdate?: Date;

    constructor(data?: IResumenTablaReferencia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tref = _data["tref"];
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            this.habilitado = _data["habilitado"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResumenTablaReferencia {
        data = typeof data === 'object' ? data : {};
        let result = new ResumenTablaReferencia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tref"] = this.tref;
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        data["habilitado"] = this.habilitado;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IResumenTablaReferencia {
    tref?: string | undefined;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    habilitado?: boolean;
    lastUpdate?: Date;
}

export class TablaReferencia implements ITablaReferencia {
    tref?: string | undefined;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    habilitado?: boolean;
    lastUpdate?: Date;
    items?: Item[] | undefined;

    constructor(data?: ITablaReferencia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tref = _data["tref"];
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            this.habilitado = _data["habilitado"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TablaReferencia {
        data = typeof data === 'object' ? data : {};
        let result = new TablaReferencia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tref"] = this.tref;
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        data["habilitado"] = this.habilitado;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITablaReferencia {
    tref?: string | undefined;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    habilitado?: boolean;
    lastUpdate?: Date;
    items?: Item[] | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}